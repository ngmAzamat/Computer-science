КАК победить на олимпиадах(мнение учителя)?

ТЕЗИС I: Можно ли победить на перечнивых, можно, автор за 1.5 года почти с нуля по c++(она программировала но забыла), и со слабыми знаниями в математике(класс лингвистики был), подготовилась.
ТЕЗИС II: ПРАКТИКА - Это нужно, решаем задачи
ТЕЗИС III: Если у вас момент решать уже нельзя, плато возможностей. Зачастую(у учителя пока всегда так) если начать решать по 100 задач в месяц то нарешиваение приводит к прорыву барьера. 
Задачи должны быть не легкие а те которые вы не можете решить, но как решать если не можем? 
Для начала рекомендуется архив сайта Codeforses.com, потому что это курто для самоподгтовки без репетитора так как там есть разборы задач. сложность от 800 и далее с шагом 100. 
Для учителя классно работает правило 30-60. 30 минут уходит на идею, чтение и обдумование, примеры и примечание. Если после 30 минут вы в тупике(Конечно если Браиншторм после 30 минут все ок), 
а если тупик то - заходим в разбор задач, причем сперва берем подсказку думаем еще берем думаем, там закончится берем разбор задач первый абзац думаем потом второй, 
на каждом этапе стараемся понять и самим идеи сдлеать, не получится весь уже разбор, и все пытаемся реализовать 30 минут. 
Если баги решаем и что то такое(я иногда по 120 минут решаю задачи но там баги) то делаем, но если тупик и идей нет то уже решение готовое. 
Но его не копируем даже если оно на c++, а понимаем что это и реализовываем сами. Дальше отправка - не получилось еще раз 30 минут.
Этоо для того чтобы не говорить? 10 минут по дебагал, наверное больше не сдвинусь, нужно смотреть решение. К этому привыкается

ТЕЗИС IV: Сложность, когда повышать? Тогда когда вы можете за час решить задачу без подсказак.
ТЕЗИС V: ТЕМЫ, пройти можно идя по курсу фоксфорд, так и идя по codeforses встречая "можно применять бинарный поиск" - начинаем изучать что это. Как изучать? Youtube. Алгортим который нужен - самое просматриваемое видео - или edu раздел на codeforses, или на информатиксе. На кодефорсисе ставится тег, но та задача с тегом скорее всего можно по-другому решить.

Коде форсес - Архив, соревнование, и еще есть отдельно там архивы олимпиад - но есть проблема тестирующей системы нету, надо искать с. И вот для этого есть тренировки можно вбить в поиск название скажем "Школьный этап Всош". Там много олимпиад. Соревнования: уровни 4 и 3 легки, на них можно ходить, 2 самый часто проводимый дивизион, 1 редкий как 4, но гораздо сложнее. НЕ стоит отменять литкод! Надо помнить - многие олимпиады не дают БВИ но дают БВИ для Бауманки. оООЧЕНЬ МНОГО ОБСУЖДЕНИЯ РАЗЛИЧНЫХ ОЛИМПИАД 25 - 35.leetcode.com

Если у нас есть ОПЕРАНД ОПЕРАТОР ОПЕРАНД. И операнды(это числа) разных типов и они приводятся к типу не-int. int к double или к long long. Поэтому есть интересный способ неявного преобразования типов:

```c++
int a = 1;
int b = 2;
cout << 1.0 * a / b;
```

или

```c++
int a = 1;
int b = 2;
cout << a * 1.0 / b;
```

так как double(1.0) умножается на int int становится double. умножение на 1 не влияет на содержание. Но теперь a = 1.0 и делясь на 2, 2 преобразовывается в double. 1.0 / 2.0 = 0.5. Если бы не было умножения на 1.0, то 1 / 2 = 0.
Но есть и янвое преобразование типов! Два варианта: `double(a)` и `(double)a`. ЗАМЕТЬТЕ! В слуачи с long long есть только `(long long)a`, в случаи `long long(a)` будет воспринято как преобразование к long и еще непонятный long впереди который вызевет ошибку.

Ну и помните:


```c++
int a = 1;
int b = 2;
cout << a / b * 1.0;
```

Будет выведено 0, так как сперва целочисленно a / b = 0, потом умножаем на 1.0 и получаем преобразованный 0.0

Также мы поговорим про остаток от деления. Итак A = B * K + X. То есть допустим это целочисленное или остаточное деление, 20 / 6, или 20 % 6. A = 20, B - 6. Чему равны K(20 / 6) и X(20 % 6)? 
Первое это то что K = деление с округлением вниз.
Начнем с того что остаток должен быть от нуля и до b - 1. Очевидно он не может быть больше или равно чем b, и не может быть меньше чем 0... А вот нет. Если A = -20, B = 6. То остаток будет... *-2*!

Математически остаток будет 4, ибо остаток не может быть отрицтельным. То есть сперва 20 / 6 с округлением вниз то есть -4. А потом `-20 = 6 * -4 + x`, то есть `-20 = -24 + x`, x очевидно равен 4.

Но c++ говорит:

Округлимся в сторону нуля, то есть `-20 / 6 = -3` и `-20 = 6 * -3 + x`, `-20 = -18 + x`. x = `-2`.

Как же на самом деле c++ это вычислил? Он вычислил так: K = -20 / 6 с округлением вниз(целочисленно). Остаток = A - (B * K). K = A / B с округлением вниз итого формула: X + A - B * (A / B) целочисленно.

Запомните! Вам скорее всего нужно будет вычислять именно математический остаток!

В положительных случаях мы по K, B, X можем вычислить A.

14:05 