КАК победить на олимпиадах(мнение учителя)?

ТЕЗИС I: Можно ли победить на перечнивых, можно, автор за 1.5 года почти с нуля по c++(она программировала но забыла), и со слабыми знаниями в математике(класс лингвистики был), подготовилась.
ТЕЗИС II: ПРАКТИКА - Это нужно, решаем задачи
ТЕЗИС III: Если у вас момент решать уже нельзя, плато возможностей. Зачастую(у учителя пока всегда так) если начать решать по 100 задач в месяц то нарешиваение приводит к прорыву барьера. 
Задачи должны быть не легкие а те которые вы не можете решить, но как решать если не можем? 
Для начала рекомендуется архив сайта Codeforses.com, потому что это курто для самоподгтовки без репетитора так как там есть разборы задач. сложность от 800 и далее с шагом 100. 
Для учителя классно работает правило 30-60. 30 минут уходит на идею, чтение и обдумование, примеры и примечание. Если после 30 минут вы в тупике(Конечно если Браиншторм после 30 минут все ок), 
а если тупик то - заходим в разбор задач, причем сперва берем подсказку думаем еще берем думаем, там закончится берем разбор задач первый абзац думаем потом второй, 
на каждом этапе стараемся понять и самим идеи сдлеать, не получится весь уже разбор, и все пытаемся реализовать 30 минут. 
Если баги решаем и что то такое(я иногда по 120 минут решаю задачи но там баги) то делаем, но если тупик и идей нет то уже решение готовое. 
Но его не копируем даже если оно на c++, а понимаем что это и реализовываем сами. Дальше отправка - не получилось еще раз 30 минут.
Этоо для того чтобы не говорить? 10 минут по дебагал, наверное больше не сдвинусь, нужно смотреть решение. К этому привыкается

ТЕЗИС IV: Сложность, когда повышать? Тогда когда вы можете за час решить задачу без подсказак.
ТЕЗИС V: ТЕМЫ, пройти можно идя по курсу фоксфорд, так и идя по codeforses встречая "можно применять бинарный поиск" - начинаем изучать что это. Как изучать? Youtube. Алгортим который нужен - самое просматриваемое видео - или edu раздел на codeforses, или на информатиксе. На кодефорсисе ставится тег, но та задача с тегом скорее всего можно по-другому решить.

Коде форсес - Архив, соревнование, и еще есть отдельно там архивы олимпиад - но есть проблема тестирующей системы нету, надо искать с. И вот для этого есть тренировки можно вбить в поиск название скажем "Школьный этап Всош". Там много олимпиад. Соревнования: уровни 4 и 3 легки, на них можно ходить, 2 самый часто проводимый дивизион, 1 редкий как 4, но гораздо сложнее. НЕ стоит отменять литкод! Надо помнить - многие олимпиады не дают БВИ но дают БВИ для Бауманки. оООЧЕНЬ МНОГО ОБСУЖДЕНИЯ РАЗЛИЧНЫХ ОЛИМПИАД 25 - 35.leetcode.com

Если у нас есть ОПЕРАНД ОПЕРАТОР ОПЕРАНД. И операнды(это числа) разных типов и они приводятся к типу не-int. int к double или к long long. Поэтому есть интересный способ неявного преобразования типов:

```c++
int a = 1;
int b = 2;
cout << 1.0 * a / b;
```

или

```c++
int a = 1;
int b = 2;
cout << a * 1.0 / b;
```

так как double(1.0) умножается на int int становится double. умножение на 1 не влияет на содержание. Но теперь a = 1.0 и делясь на 2, 2 преобразовывается в double. 1.0 / 2.0 = 0.5. Если бы не было умножения на 1.0, то 1 / 2 = 0.
Но есть и янвое преобразование типов! Два варианта: `double(a)` и `(double)a`. ЗАМЕТЬТЕ! В слуачи с long long есть только `(long long)a`, в случаи `long long(a)` будет воспринято как преобразование к long и еще непонятный long впереди который вызевет ошибку.

Ну и помните:


```c++
int a = 1;
int b = 2;
cout << a / b * 1.0;
```

Будет выведено 0, так как сперва целочисленно a / b = 0, потом умножаем на 1.0 и получаем преобразованный 0.0

Также мы поговорим про остаток от деления. Итак A = B * K + X. То есть допустим это целочисленное или остаточное деление, 20 / 6, или 20 % 6. A = 20, B - 6. Чему равны K(20 / 6) и X(20 % 6)? 
Первое это то что K = деление с округлением вниз.
Начнем с того что остаток должен быть от нуля и до b - 1. Очевидно он не может быть больше или равно чем b, и не может быть меньше чем 0... А вот нет. Если A = -20, B = 6. То остаток будет... *-2*!

Математически остаток будет 4, ибо остаток не может быть отрицтельным. То есть сперва 20 / 6 с округлением вниз то есть -4. А потом `-20 = 6 * -4 + x`, то есть `-20 = -24 + x`, x очевидно равен 4.

Но c++ говорит:

Округлимся в сторону нуля, то есть `-20 / 6 = -3` и `-20 = 6 * -3 + x`, `-20 = -18 + x`. x = `-2`.

Как же на самом деле c++ это вычислил? Он вычислил так: K = -20 / 6 с округлением вниз(целочисленно). Остаток = A - (B * K). K = A / B с округлением вниз итого формула: X + A - B * (A / B) целочисленно.

Запомните! Вам скорее всего нужно будет вычислять именно математический остаток!

В положительных случаях мы по K, B, X можем вычислить A.

Строго говоря Есть задачи две. Первая: яблоки(n) делятся между школьниками(k) поровно, кому сколько? Сперва K, потом N. Вторая задача: Сколько яблок в корзине оставят.

Первое:

```c++
#include <iostream>
using namespace std;
int main () {
    int n, k;
    cin >> k >> n;
    cout << k / n;
    return 0;
}
```

Второе:

```c++
#include <iostream>
using namespace std;
int main () {
    int n, k;
    cin >> n >> w;
    cout << k % n;
    return 0;
}
```


Задача: школьники делят яблоки почти поровну:

1. Сперва раздают каждому по яблоке потом еще и пока яблок не останется меньше школьников
2. Раздают оставшиеся яблоки так чтобы никому не досталось меньше чем на два(то есть раздает по 1 яблоку, в таком случаи никто не будет на более одного иметь яблок больше чем другие, другие не будут иметь яблок мнеьше чем одного яблока)
3. Сколько людей получат меньше яблок?

Итак люди = n, сколько яблок осталось в корзине(как следствие разданы другим) = k % n; Те люди которым досталось меньше это все люди минус те у которых доп яблоко. n - k % n; Это работает в случаи что K = 30, N = 7.

Но если K = 28, N = 7. То в реальности никому не досталось меньше. Тогда как программа говорит: Всем досталось меньше. 28 % 7 = 0, 7 - 0 = 7. 7 Людям досталось меньше. Должно быть 0. Но если мы возьмем это в скобки и возьмем остаток от деления на N.

У нас K % N - не может быть отрицательным, N не может быть отрицательным. Остаток в принципе не может быть отрицательным(когда там не изпользуется отрицательные числа в c++), N - K % N. Может быть равен от нуля и до N.

Теперь если N - K % N = N. То мы берем остаток от N, и получается N % N = 0, что нам и нужно(0 людей получили меньше), а если N - K % N меньше N, То остаток от деления на N, ничего не сделает.

(N - K % N) % N;

Кольца Вычетов. Глава I.

Итак У нас 12 часов и у нас две задачи которые условно займут 5 и 15 часов. Сколько времени(на часах будет), нам не важно сколько пройдет, сколько будет на часах? (5 + 15) % 12 = 20 % 12 = 8.
Но также мы можем разложить: 5 % 12 + 15 % 12 = 5 + 3 = 8. Но иногда может быть: 11 % 12 + 11 % 12 = 22. Но часов 12. Поэтому дополнительно берем остаток: (5 % 12 + 15 % 12) % 12.
Для чего это? Если у мы будем сперва что в скобках считать, там числа могут быть больше типа лонг лонг а так мы по отдельность берем числа до 11 и скалываем, потом еще и потом в финале еще раз до 11 число получаем.
Это есть кольца вычетов - главное отличие от циферблата - нету 12, есть 0, ведь 12 % 12 = 0, а не 12.

Есть также и с умножением!

A * B % N = ((A % N) * (B % N)) % N

Почему? Сложный вопрос, то это работает.

Если мы допускаем возможность как положительных так и отрицательных, то(Вебинар: 1:16:40 - 1:21:00) показывают почему нужно для остатка изпользовать (A % N + N) % N; Математика - сложна.

ГЛАВА "Свойства операций по модулю": Мы не делим по модулю(там сложная механика), и изпользую технику вычитания по модюлю схожую технику. 

Там строго говоря хороший слайд 1:23:00



### Ульта задача(Жаль решил не совсем сам)

итак МКАД - скорость v и время t, сколько проедет? V * T. Если со сторостью 60 ехать 2 часа = 60 * 2 = 120. Далее нам надо узнать на какой точке от 0 и до 108. для этого берем остаток от деления на 109.

```c++
#include <iostream>
using namespace std;
int main() {
    int v, t;
    cin >> v >> t;
    cout << (v * t) % 109 << endl;
}
```

Но мы допускаем отрицательное v, то есть мотоциклист будет ехать против часовой и опустим он едет 1 час со скоростью -1. Для нас он должен остановится на 108, а в такой программе на каком то месте -1. Это нам ничего не говорит. но если будет 10 часов? Будет -10. А должно быть 109-10=99. итак соотношение одинаково: между -1 и 108, 109 и между -10 и 99 тоже 109. значит для отрицательный чисел это как мы обсуждали работает, добавим случай для положительных:


```c++
#include <iostream>
using namespace std;
int main() {
    int v, t;
    cin >> v >> t;
    cout << (v * t % 109 + 109) % 109 << endl;
}
```

МашаЛлах! Я написал правильный код! Вообщем - если бы вы не брали бы сперва остаток а сразу бы прибовляли то тогда число могло бы остатся отрицательным будучи -500 + 109 не будет положительным а -500 % 109 + 109  будет положительным!

### Числа

Итак что делают с числами?

Чтобы получать последнее число надо брать % 10, а предпоследнее / 10 % 10. А

1:35:00 - где то раньше рассуждения

Нам дается число секунда надо вывести время.


```c++
#include <iostream>
using namespace std;
int main() {
    int n;
    cin >> n;
    int h, m, s;
    int kof = 60 * 60;
    int h = n / kof;
    int m = (n - h * kof) / 60;
    int s = n - (h * kof + m * 60) 
}
```

Это было странно, учитель предложил(что логично):

```c++
#include <iostream>
using namespace std;
int main() {
    int n;
    cin >> n;
    int h, m, s;
    h = n / 3600;
    n -= h * 3600;
}
```

Мы хотив убрать что было, убрать и секунда наши часы. Но на деле это тоже что взять то что осталось после деления на часы - надо брать остаток от деления на 3600, и тоже с минутами:

```c++
#include <iostream>
using namespace std;
int main() {
    int n;
    cin >> n;
    int h = n / 3600;
    n %= 3600
    int m = n / 60;
    n %= 60;
    cout << h << ':' << m << ':' <<  n << endl;
}
```

При вводе 3602 будет 1:0:2. А хотелось: 1:00:02. Я хотел через if. А учитель хочет так:


```c++
#include <iostream>
using namespace std;
int main() {
    int n;
    cin >> n;
    int h = n / 3600;
    n %= 3600
    int m = n / 60;
    n %= 60;
    cout << h << ':' << m / 10 << m % 10 << ':' <<  n / 10 << n % 10 << endl;
}
```

Это работает, так как 2 / 10 = 0, 2 % 10 = 2. А 59 / 10 = 5, 59 % 10 = 9. Теперь добавим вначале остаток от деления на 24.

```c++
#include <iostream>
using namespace std;
int main() {
    int n;
    cin >> n;
    int h = (n / 3600) % 24;
    n %= 3600
    int m = n / 60;
    n %= 60;
    cout << h << ':' << m / 10 << m % 10 << ':' <<  n / 10 << n % 10 << endl;
}
```

Все работает! МашаЛлах! 


14:05 

