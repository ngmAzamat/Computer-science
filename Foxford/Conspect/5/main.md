Учитель студент 3 курса Вышки, говорит что на собесах с яндексом алгоритмы есть, они есть и на 1-2 урсах вышки, по ним чтоле 4 предмета было. И это важно, круто, интересно. Сама она за 1.5 года подготовилась к перечнивым.

Цель: разбор домашки, задач и алгоритмов с изпользованием if и циклов. Работа с последовательностью.

Интересный факт: в C++ можно писать and, or, not вместо &&, ||, !

Do while есть но изпользвуется он только когда перебираем перестоновки

++a работает быстрее не намного но быстрее чем a++

Также есть разница::

```c++
int a = 5;
int b = a++;
```

и 

```c++
int a = 5;
int b = ++a;
```

В первом варинате будет: b = 5, a = 6. а во-втором b = 6, a = 6. Так как в ++a сперва вычисляется новое значение a а потом оно присваевается b, в отличии от a++; Там дело в том что a++ создает какую то временную копию ...



## Шаг I:

Определяем вход и выход:

1. Число(извесное число чисел - например вводится два числа) - вход, Число - выход. Например факториал, сумма, и много чего еще
2. Число - вход, Последовательность(какое-то число чисел, в условии задачи не извесное) - выход. Например все числа между двумя указанными числами
3. Последовательность - вход, Число - выход. Например сумма всех чисел.
4. Последовательность - вход, Последовательность - выход. Чаще всего изпенение Последовательности и фильтрация, Сортировка.

y = x^a

Для начала переменные, потом цикл:

```c++
#include <iostream>
using namespace std;
int main() {
    int x, a;
    int y = 0;
    cin >> x >> a;
    cout << y << endl;
}
```

лайфхак: Если цикл начинается с 0, и < n. То будет ровно n итераций.
Давайте x = y, далее будем понимать что если a = 2. То x в степени 2, это будет X * X то есть надо X умножить на себя a - 1 раз. При чем y базаво должен быть уже x, чтобы это сделать. При чем надо умножать не x, а уже перемноженные x.

```c++
#include <iostream>
using namespace std;
int main() {
    int x, a;
    cin >> x >> a;
    int y = x;
    for (int 0; i < a - 1; i++) {
        y = y * x;
    }
    cout << y << endl;
}
```

Помним что `y = y * x` это еще и `y *= x`, также мы можем не писать a - 1, а просто начинать с 1 и идти по a. А еще лучше чтобы i соотносилось со степенью, чтобы вторая степень(начальная) была когда i = 2... и для этого мы можем уже идти до a ВКЛЮЧИТЕЛЬНО:

```c++
#include <iostream>
using namespace std;
int main() {
    int x, a;
    cin >> x >> a;
    int y = x;
    for (int 2; i <= a; i++) {
        y *= x;
    }
    cout << y << endl;
}
```

Но если a = 0, то тогда то оказывается что for даже не начинается(условие не выполнено) и сразу выводится y - который равен x. А в дейстивтельнсти должно быть x^0 то есть 1. Поэтому: надо взять и в начале сделать y = 1; и добавить еще одну итерацию цикла(чтобы 1 * x = x и только потом степени). При чем первая итерация будет степенью 1, вторая степенью 2... поэтому мы поменяем базовый i с 2, на 1:

```c++
#include <iostream>
using namespace std;
int main() {
    int x, a;
    cin >> x >> a;
    int y = 1;
    for (int 1; i <= a; i++) {
        y *= x;
    }
    cout << y << endl;
}
```

Еще желательно делать x типом long long. так как просто x = 6, a = 21. Выгдялит немного, но!


Fun fact: a/b с округлением вверх, это a + b - 1/b с округлением вниз. Два примера:

1. a = 3. b = 2. 3/2 вверх = 2. 3 + 2 - 1 = 4. 4/2 = 2.
2. a = 4. b = 2. 4/2 вверх = 2. 4 + 2 - 1 = 5. 5/2 = 2.

КАК ЭТО работает? Тут дело в чем: Если a/b без остатка, то + b - 1 он делится вниз будет так же. То есть Если a = 1b. то a + b - 1 = 2b - 1. то есть не дотягивает до 2b, а значит при делении вниз будет равно 1b. А если у нас a на хотя бы один больше чем k(1 или там 3)b, то мы попаадем из скажем 1b + 1 в 2b, или из 2b - 1 в 3b - 2. То есть попадем вверх(недостаточно для 3b, что хорошо) и огруглимся вниз по правильному.
Вот надеюсь объяснил.

Задача два. Квадрат: Число - вход, Последовательность - выход. Собственно вводится `a`, и от `a` идется арифметическая прогрессия к `f(включительно)` с шагом `d`, не равном нулю(в математике однако, последовательность с шагом 0 есть и называется статической последовательностью). Собственно надо это реализовать через if() То есть если f отрицательный то наш цикл идет пока правдой будет `current >= f`, если положительный `current <= f`, собственно у нас есть еще вариант что `f = 0`

Итак:

```c++
#include <iostream>
using namespace std;
int main() {
    int a, b, c;
    cin >> a >> b >> c;
    if (c > 0) {} else if (c < 0) {} else {}
}
```

В каждом if должен быть цикл while() непосретственно увеличивающий(или уменьшающий) a и идущий к f, дальше f будет увеличиватся на b, пока не станет равным или большим(меньшим) f:

```c++
#include <iostream>
using namespace std;
int main() {
    int a, b, c;
    cin >> a >> b >> c;
    if (c > 0) {
        while(a <= c) {
            a += b;
        }
    } else if (c < 0) {
        while(a >= c) {
            a += b;
        }
    } else {}
}
```

Но на самом деле нам важно не c, а b, ведь если b положительное то мы увеличиваем число и будем это делать пока не дойдем до, а есл b отрицательное пока не опустимся:

```c++
#include <iostream>
using namespace std;
int main() {
    int a, b, c;
    cin >> a >> b >> c;
    if (b > 0) {
        while(a <= c) {
            a += b;
        }
    } else if (b < 0) {
        while(a >= c) {
            a += b;
        }
    } else {}
}
```

К слову нам else if не нужен - случая b = 0 по условию нет:

```c++
#include <iostream>
using namespace std;
int main() {
    int a, b, c;
    cin >> a >> b >> c;
    if (b > 0) {
        while(a <= c) {
            a += b;
        }
    } else {
        while(a >= c) {
            a += b;
        }
    }
}
```


Но на самом деле:


```c++
#include <iostream>
using namespace std;
int main() {
    int a, b, c;
    cin >> a >> b >> c;
    int sign = 1;
    if (b < 0) {
        sign = -1;
    } 
    for(int i = a; i * sign <= c * sign; i += b) {
        cout << i << ' ';
    }
}
```
Но на самом деле:


```c++
#include <iostream>
using namespace std;
int main() {
    int a, b, c;
    cin >> a >> b >> c;
    for(int i = a; min(i, c) <= i && i <= max(i, c); i += b) {
        cout << i << ' ';
    }
}
```


А геомтерическая прогрессия? Давайте начнем что b будет больше 0, равным 0 оно не может из приницпа геометр. прогрессии, а если бы оно могло бы быть меньше было бы сложно. Итак во-первых меняем i+=b на i += b. Ну и да в каких ситуациях при умножении на что-то что-то уменьшается? Если b < 1. Поэтому:

```c++
#include <iostream>
using namespace std;
int main() {
    int a, b, c;
    cin >> a >> b >> c;
    int sign = 1;
    if (b < 1) {
        sign = -1;
    } 
    for(int i = a; i * sign <= c * sign; i *= b) {
        cout << i << ' ';
    }
}
```


Нельзя не отметить, что если программа подроззумевает уменьшающуюся прогрессию, то у нас должны быть дробные double, а не целые int:

```c++
#include <iostream>
using namespace std;
int main() {
    double a, b, c;
    cin >> a >> b >> c;
    int sign = 1;
    if (b < 1) {
        sign = -1;
    } 
    for(int i = a; i * sign <= c * sign; i *= b) {
        cout << i << ' ';
    }
}
```

ТЕПЕРЬ: вход: последовательность, выход: число.

Однопроходные алгоритмы - те в которых надо один раз пройтись по последовательности, и все, нам даже не нужно на деле в массив запоминать, условно количество чисел в последовательности можно считать по мере ввода чисел. Среди однопроходных: максимум, минимум, количсетво, сумма, произведение. Но есть и не однопроходные. Проходит их будут когда будут массива. А пока идея однопроходных в том что массивы не нужны. Это эффективно и не требует много памяти.


Так как мы еще "не знаем как считывать последовательность", будем работать с последовательностью которую мы уже создовали, для начала поймем что мы строго говоря заполняем бланк, состоящий из: базового значение для числа и того кака мы подсчитываем число. У нас будет сейчас количество элементов, собственно пока у нас элементов нету, базовое значение 0. Каждый раз в цикле находя значие мы будем добавлять один(++):

```c++
#include <iostream>
using namespace std;
int main() {
    int a, b, c;
    cin >> a >> b >> c;
    int sign = 1;
    if (b < 0) {
        sign = -1;
    } 
    int counter = 0;
    for(int i = a; i * sign <= c * sign; i += b) {
        cout << i << ' ';
        counter++;
    }
}
```

А если мы сумму считаем то-что? Мы просто каждую находящиюся число добавляем через +=. Начинается также с 0:

```c++
#include <iostream>
using namespace std;
int main() {
    int a, b, c;
    cin >> a >> b >> c;
    int sign = 1;
    if (b < 0) {
        sign = -1;
    } 
    int counter = 0;
    for(int i = a; i * sign <= c * sign; i += b) {
        cout << i << ' ';
        counter += i;
    }
}
```

В произведении все хитрее: базовое значение будет 1, ведь если бы было бы ноль, то произведение 0 * x = 0... а собственно бы будем перемножать уже имеющийся counter на новое искомое число:

```c++
#include <iostream>
using namespace std;
int main() {
    int a, b, c;
    cin >> a >> b >> c;
    int sign = 1;
    if (b < 0) {
        sign = -1;
    } 
    int counter = 1;
    for(int i = a; i * sign <= c * sign; i += b) {
        cout << i << ' ';
        counter *= i;
    }
}
```

А как вводить числа?
Если нам извесно сколько чисел вводится, то мы можем одним циклом считать эти числа и скажем внутри что-то сделать с вводимым числом:

```c++
#include <iostream>
using namespace std;
int main() {
    int n;
    cin >> n;
    for(int i = 0; i < n; i++) {
        int a;
        cin >> a;
        // что-то делаем
    }
}
```

Есть так называемый вариант с "терминальной точкой", вводим пока не получим число скажем 0:

```c++
#include <iostream>
using namespace std;
int main() {
    int a;
    cin >> a;
    while(a != 0) {
        // что-то делаем
        cin >> a;
    }
}
```

Есть вариант с "неограниченной последовательностью":


```c++
#include <iostream>
using namespace std;
int main() {
    int x;
    while(cin >> a) {
        // что-то делаем
    }
}
```

Собственно while(cin >> a) это while который идет пока мы возвращаем то что ошибок нету. То есть пока у нас ввод считовается нормально. Неудается считать cin если у нас несоответсвие по типам(ввод не int например), либо конец файла считования(пример: мы передаем на вход программе какой-то файл). Но при вводе с консоли можно либо сделать ifом стоп-слово. либо вводить другой тип если возможно.

Задача: ввод - последовательность, вывод - последовательность. дается n, потом последовательность длинной n, и надо через пробелы вывести только четные:

```c++
#include <iostream>
using namespace std;
int main() {
    int n;
    cin >> n;
    for(int i = 0; i < n; i++) {
        int a;
        cin >> a;
        if (a % 2 == 0) {
            cout << a << ' ';
        }
    }
}
```

заметьте мы все еще можем делаеть это без массива!
