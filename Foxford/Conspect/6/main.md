Тип bool имеет два значения: 0 или 1(true или false) что можно запясать в один бит. Однако хоть и в c++ есть такая возможность она почти не применяется, гораздо легче хоть и запясать один бит, но выделить один байт и таскать из одного байта... вообщем что-то такое.

тип обозночается именем bool. Явное преобразование выглядит вот так:

`bool flag = ((x + 1) > 0);`

Вы знали что есть помимо ! еще и not, помимо && еще и and, помимо || есть еще и or. На самом деле от языка c, осталось еще и ~(вместо !), &(вмсето &&), |(вмсето ||). Эти штуки даже не полностью идентичны обычным.
Они называются битовыми операторами. И делаеют какую то арифметику а не логику и вообще не изпользуйте их. 

Но не об этом.

есть явное преобрахование в bool производится bool(). Все кроме ноль - true, ноль - false. обратное преобразование работает через int(), false - 0, true - 0. Также чтобы преобразовать любое число в 1, кроме 0. 
Можно изпользовать not not, !!... Логические переменные скалыдвать нельзя... НО есть неявное преобразование:

1. int неявно в bool: когда произходит логическая операция - например or, not, and. Пример: x(2) || y(0) = true

2. bool неявно в int: когда два bool арифметически оперируются(+ или -). пример: x(true) + y(true) = 2

В логике извесно: A и B, B и A - одинаково. A или B, B или A, одинаково. НО НЕ В C++!. Дело в том, что оператор and(начнем с него) он ленивый. Дело в том что если у нас `if(f(x) and g(x))` и f(x) == false, то программа просто не будет вычислять что g(x), потому что понятно что and уже не выполнится. Это озночает, что A и B, и B и A, они разные, в одном может будет 2 проверки, а в другом может сразу false и дальше вычислятся не будет.

Это к чему. А к тому что на деле абсурдный(с некоторами компиляторами неработающий пример но вот): 
`if (x / y > 0 || y == 0)` - в этом примере кроется возможная проблема, если `y` это 0. Ведь тогда программа может начать считать x / 0 у может улететь в трубу. Если же поменять местам и сделать так: `if (y == 0 || x / y > 0)` то так как программа ленивая, увидев что y = 0, она скажет что этого достаточно так как надо чтобы хоть что то было бы правдой, и программа не улетить вычислять нехорошое. Но некоторые умные компиляторы понимают что к чему и в обеих версиях ведут себя тихо.

Теперь об if, допустим наше число `x` надо понять в каком оно секторе: A(менее 0), B(0 - 49), C(50 - 99), D(100+). Есть вариант через switch, который учитель не рекомендует, ведь там нужны break...

Зато есть два варианта с if:
1. Вложенные if. Сперва проверяем меньше ли чем 50 x, и дальше проверяем меньше ли оно 0, а если больше или равно 50 то проверка больше или равно 100. Итого за 2 if мы гарантированно находим сектор x, это работает быстро - только 2 if, но читается хуже, и не может сделать одну фишку которую может делать вариант под номером два
2. Вариант псевдо switch, состоит из if, else if, else if, else. Этот вариант более легко читается. более того вместо завершающего else можно сделать else if, а else сделать сообщение cout << "AHTUNG!". Но при том помнить важно, что иногда можно как одним так и 4 if-ами найти сектор. То есть работает медленнее. Надеюсь это понятно.


Теперь представим что нам вводят числа и мы должны сосчетать сколько в этих числах числа x0. вводится n чисел:

```c++
#include <iostream>

using namespace std;

int main()
{
    int N;
    cin >> N;  // сколько будет чисел
    int x, x0;
    cin >> x0;  // число, которое буду искать
    int counter = 0;
    for (int i = 0; i < N; i++) {
        cin >> x;
        if (x == x0)
            counter++;
    }
    cout << counter << '\n';
}
```

Любопытная деталь, мы можем изпользовать один факт: правда(true) преобразовывается в один, а ложь в 0. соответственно мы можем без if просто приповлять (x == x0), если это правда то counter увеличится на один, иначе ничего(что собственно нам и нужно):

```c++
#include <iostream>

using namespace std;

int main()
{
    int N;
    cin >> N;  // сколько будет чисел
    int x, x0;
    cin >> x0;  // число, которое буду искать
    int counter = 0;
    for (int i = 0; i < N; i++) {
        cin >> x;
        counter += (x == x0);
    }
    cout << counter << '\n';
}
```


А если нужно просто узнать есть ли число? более того с помощью if мы можем даже цикл ввода через break при вводе искомого числа остановить

```c++
#include <iostream>

using namespace std;

int main()
{
    int N;
    cin >> N;  // сколько будет чисел
    int x, x0;
    cin >> x0;  // число, которое буду искать
    bool is_x0_present = false;
    for (int i = 0; i < N; i++) {
        cin >> x;
        if (x == x0) {
            is_x0_present = true;
            break;
        }
    }
    cout << is_x0_present << '\n';
}
```

Мы также можем сделать `is_x0_present = is_x0_present || x == x0`, это будет озночать, что is_x0_present будет равен true, если либо он уже раньше был true либо если сейчас x равен искомому число. Но теперь мы не можем изпользовать break. Также извесно что есть |= что озночает то же что и += но только с битовом(ВАЖНО, это минус) оператором |:

```c++
#include <iostream>

using namespace std;

int main()
{
    int N;
    cin >> N;  // сколько будет чисел
    int x, x0;
    cin >> x0;  // число, которое буду искать
    bool is_x0_present = false;
    for (int i = 0; i < N; i++) {
        cin >> x;
        is_x0_present |= (x == x0);
    }
    cout << is_x0_present << '\n';
}
```

А теперь допустим нам надо проверить все ли числа равны x0:

```c++
#include <iostream>

using namespace std;

int main()
{
    int N;
    cin >> N;  // сколько будет чисел
    int x, x0;
    cin >> x0;  // число, которое буду искать
    bool is_x0_present = true;
    for (int i = 0; i < N; i++) {
        cin >> x;
        is_x0_present &= (x == x0);
    }
    cout << is_x0_present << '\n';
}
```


Необязательно равны, можно просто если все числа положительны(больше 0):

```c++
#include <iostream>

using namespace std;

int main()
{
    int N;
    cin >> N;  // сколько будет чисел
    int x;
    bool is_all_positive = true;
    for (int i = 0; i < N; i++) {
        cin >> x;
        is_all_positive &= (x > 0);
    }
    if (is_all_positive)
        cout << "all positive" << '\n';
    else
        cout << "not all positive" << '\n';
    return 0;
}
```

а теперь найдем максимальное число, для начала зададим перменную с наименьшим значением(условно наименьшим), и если число больше то значение оббновляется 

```c++
#include <iostream>

using namespace std;

int main()
{
    int N;
    cin >> N;  // сколько будет чисел
    int x, m;
    m = -10000000;  // инициализация
    for (int i = 0; i < N; i++) {
        cin >> x;
        if (x > m) {
            m = x;
        }
    }
    cout << "max =" << m << '\n';
    return 0;
}
```

По похожому принципу делаем минимальное число

```c++
#include <iostream>

using namespace std;

int main()
{
    int N;
    cin >> N;  // сколько будет чисел
    int x, m;
    m = 10000000;  // инициализация
    for (int i = 0; i < N; i++) {
        cin >> x;
        if (x < m) {
            m = x;
        }
    }
    cout << "max =" << m << '\n';
    return 0;
}
```

Проблема: допустим у нас 0 чисел, N == 0. Тогда максимум будет равен -10000000. или минимум 10000000. На деле реально максимума просто нету так как чисел нету. Но на первый взгляд эту ситуацию легко избежать!
Ведь можно сперва считать первое число и положить как базавый максимум. Пример:

```c++
#include <iostream>

using namespace std;

int main()
{
    int x, m;
    cin >> x;
    m = x; // первое значение
    while(x != 0) {
        if(x % 2 == 0 && x > m) {
            m = x;
        }
        cin >> x;
    }
    cout << "max = " << m << '\n';
    return 0;
}
```

Данная программа выбирает все четные числа и вычисляет максимум из них. Конец ввода - терминальная точка 0. Причем если чисел будет 0, то максимум будет равен 0. Этот пример нам дает однако еще одну ошибку!
Дело в том что первое значение может быть нечетным, при том что мы этого не проверяет. Мало того, значение первое может быть более всех остальных, а чтобы новый максимум возник, надо не только четность, но и быть больше преведущего максимума. В итоге в результате может быть окажется нечетное число.

Заведем буллевую переменную


Книги на тему c++? Это про промышленое программирование что не совсем нужно для олимпиад, и Кормен про алгоритмы с примерами на c++. Именно по языку рекомендуют вот что: фоксфорд учебник.