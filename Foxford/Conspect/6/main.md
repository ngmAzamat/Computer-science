Тип bool имеет два значения: 0 или 1(true или false) что можно запясать в один бит. Однако хоть и в c++ есть такая возможность она почти не применяется, гораздо легче хоть и запясать один бит, но выделить один байт и таскать из одного байта... вообщем что-то такое.

тип обозночается именем bool. Явное преобразование выглядит вот так:

`bool flag = ((x + 1) > 0);`

Вы знали что есть помимо ! еще и not, помимо && еще и and, помимо || есть еще и or. На самом деле от языка c, осталось еще и ~(вместо !), &(вмсето &&), |(вмсето ||). Эти штуки даже не полностью идентичны обычным.
Они называются битовыми операторами. И делаеют какую то арифметику а не логику и вообще не изпользуйте их. 

Но не об этом.

есть явное преобрахование в bool производится bool(). Все кроме ноль - true, ноль - false. обратное преобразование работает через int(), false - 0, true - 0. Также чтобы преобразовать любое число в 1, кроме 0. 
Можно изпользовать not not, !!... Логические переменные скалыдвать нельзя... НО есть неявное преобразование:

1. int неявно в bool: когда произходит логическая операция - например or, not, and. Пример: x(2) || y(0) = true

2. bool неявно в int: когда два bool арифметически оперируются(+ или -). пример: x(true) + y(true) = 2

В логике извесно: A и B, B и A - одинаково. A или B, B или A, одинаково. НО НЕ В C++!. Дело в том, что оператор and(начнем с него) он ленивый. Дело в том что если у нас `if(f(x) and g(x))` и f(x) == false, то программа просто не будет вычислять что g(x), потому что понятно что and уже не выполнится. Это озночает, что A и B, и B и A, они разные, в одном может будет 2 проверки, а в другом может сразу false и дальше вычислятся не будет.

Это к чему. А к тому что на деле