Во имя Аллаха, Милостевого, Милосердного!

# Глава Метод и Задача I:

Метод грубой силы или же Bruteforse, это простой перебор всего в поисках ответа.

Задача: Дан билет с 6 цифрами. Найти сколько билетов где сумма первых трех цифр равна сумме последних трех цифр.

Теперь представим у вас 2 числа от 0 до 9, сколько вариантов может быть что они одинаковы? 9! Если 0-0,1-1. ИТД.

А теперь это составим таблицу с суммами двух цифр. итак у нас есть суммы и надо знать сколько способов получить их:

Сумма 0 - есть один способ 0 - 0
1: 1 - 0 и 0 - 1. 2 способа
2: 0 - 2, 2 - 0, 1 - 1. 3 способа
9: 0 - 9, 1 - 8, 2 - 7, 3 - 6, 4 - 5, 5 - 4, 6 - 3, 7 - 2, 8 - 1, 9 - 0. 10 способов.

Мы замечаем что от 0 до 9 у суммы есть n + 1 вариантов как получить эту сумму из ЦИФР(0 - 9).

НО Сумма 10, Ее нельзя получить способом 10 + 0. Ведь у нас сумма из двух цифр! а 10 не цифра. Получить суммой из двух цифр можно так:

1 - 9, 2 - 8, 3 - 7, 4 - 6, 5 - 5, 6 - 4, 7 - 3, 8 -2, 9 - 1. 9 вариантов!

А 11: 2 - 9, 3 - 8, 4 - 7, 5 - 6, 6 - 5, 7 - 4, 8 - 3, 9 - 2. 8 Вариантов! Уменьшается

Пока идет до 18, где будет один вариант - 9 и 9. 


Итак: теперь к задаче(с двумя), у нас сколько 4 символьных билетов которых первые две(сумма) равна второй сумме?

Итак начнем с суммы 0 равной сумме ноль. У нас один вариант для первой нулевой суммы(0 и 0), и для второй тоже. Всего есть один вариант такого билета 0000. Теперь сумма 1 и сумма 1.

4 варианта(2 варианта первой суммы и по два варианта второй суммы для каждого из вариантов первой суммы):

0101
0110
1001
1010

И это определения `2 варианта первой суммы и по два варианта второй суммы для каждого из вариантов первой суммы`, озночает что нужно умножить варианты первой суммы на варианты второй суммы, так как они равны, надо возвести в квадрат варианты суммы. То есть надо сложить квадраты от 1 до 9, умножить все это на 2 так как числа до 9 возрастают, но потом убывают, а квадраты там одинаковы, и еще прибавить надо 100, 10^2. Так как есть до 9, после 9, и само 9.

(1^2 + 2^2 + 3^2 + ... + 9^2) * 2 + 100


Теперь с тремя числами. И если кратко то так как теперь суммы до 27, а цифр 9, и три из них задействованы единовременно, то математика слишком сложно. Вот сумма три:

0 0 3
0 3 0
3 0 0
1 1 1
1 2 0
0 1 2
2 1 0
0 2 1
1 0 2
2 0 1

Закономерности найти сложно, и вот наконец мы можем просто начать все переберать.

```c++
#include <iostream>
using namespace std;
int main() {
    for(int x1 = 0; x1 < 9; x1++) {
        for(int x2 = 0; x2 < 9; x2++) {
            for(int x3 = 0; x3 < 9; x3++) {
                for(int x4 = 0; x4 < 9; x4++) {
                    for(int x5 = 0; x5 < 9; x5++) {
                        for(int x6 = 0; x6 < 9; x6++) {    
                            if (x1 + x2 + x3 == x4 + x5 + x6) {
                                n++;
                            }        
                        }
                    }
                }
            }
        }
    }
    cout << n << endl;
}
```

Это с Божьей Волей работает.

А если с 10 цифрами, а не с 6, то ответ будет искатся наверное около 20 секунд:

```c++
#include <iostream>
using namespace std;

int main()
{
    int n = 0;
    for (int x1 = 0; x1 < 9; x1++)
        for (int x2 = 0; x2 < 9; x2++)
            for (int x3 = 0; x3 < 9; x3++)
                for (int x4 = 0; x4 < 9; x4++)
                    for (int x5 = 0; x5 < 9; x5++)
                        for (int x6 = 0; x6 < 9; x6++)
                            for (int x7 = 0; x7 < 9; x7++)
                                for (int x8 = 0; x8 < 9; x4++)
                                    for (int x9 = 0; x9 < 9; x5++)
                                        for (int x10 = 0; x10 < 9; x10++)
                                            if (x1 + x2 + x3 + x4 + x5 == x6 + x7 + x8 + x9 + x10)
                                                n++;
    cout << n << "\n";
    return 0;
}```

Но есть способ это уменьшить(С Дозволения Аллаха), а также его превратить в общий случай с возможностью указать сколько цифр с одной стороны(y), скольки-ричная система счисления(x):

```c++
#include <iostream>
#include <cmath>

using namespace std;

int main()
{
    int n = 0, x, y;
    cin >> x >> y;
    for (long long int z = 0; z < pow(x, 2*y); z++) {
        int s1 = 0, s2 = 0;
        long long z_copy = z;
        for(int i = 0; i < y; i++) {
            s1 += z_copy % x;
            z_copy /= x;
        }
        for(int i = 0; i < y; i++) {
            s2 += z_copy % x;
            z_copy /= x;
        }
        if (s1 == s2) n++;
    }
    cout << n << "\n";
    return 0;
}
```

Что это я не знаю. Но мы должны перебрать пока z меньше 10^6(то есть последнее число 999 999), а не до 10^3, поэтому `y * 2`.

# Глава II: Простые числа

Итак у нас у каждого числа есть делители Тревиальные(1 и n), и нетревивиальные(от 2 до n-1). 1 не является простым числом по мнению учителя так как у него лишь один а не два делителя. 0 делится на все. это число исключено.

Делители всегда делятся на пары. Первый и последний, второй и n-1, 3 и n-2, пример число 6:

1 * 6 = 6
2 * 3 = 6

Но например у числа 9, тоже есть пары, срединный делитель 3, берет себе в пару себя же:

1 * 9 = 9
3 * 3 = 9

Ну и наконец 12:

1 * 12
2 * 6
3 * 4
...

Почему это работает?

Если у нас число x делится на y, то в результате будет целое число z, и не будет остатка. Если `x / y = z`, значит `x / z = y`. а `x = y * z`. То есть если мы делим `12 / 6 = 2`, то 12 тоже делится на 2, и далее вывод: `12 = 6 * 2`. это же работае с 9 / 3 = 3, значит 3 * 3 = 9. вот так!

Путем вычислений на 1:02:00 где-то мы понимаем что надо нам c `(Меньшее из y, z) в квадрате <= X <= (Большее из y, z)^2` Причем если `d1^2 = x = d2^2`, то есть d1 и d2 равны корню из x. Заключение: Только тогда если x полный квадрат, число делителей будет нечетным.

Пример 9 - полный квадрат, есть как 1 * 9, 9 * 1, а посередине есть 3 * 3, у числа скажем не полного квадрата всегда четное число делителей.


Получается что то только если x, является полным квадратом какогото числа, то тогда может быть что `y` и `z` равны.

От 1 до N, включительно можно поставить два сектора A(от 1 до Корень из X включительно) и B(От корня из X включительно до N включительно). И делитель из сектора A имеет пару из сектора B и наоборот.

Вопрос как можно узнать все нетривиальные делители числа? Перебрать все числа от 2 до N; Это долго.

Теперь тоже перебор + головной мозг

перебор обычный:

```c++
#include <iostream>
using namespace std;

int main()
{
    int n = 0;
    long long x;
    cin >> x;
    for (long long d = 2; d < x; d++) {
        if (x % d == 0)
            n++;
    }

    cout << n << "\n";
    return 0;
}
```

Мда, а что если мы переберем только сектор A, а если будем находить в секторе A делитель, мы знаем что у нас будет пара из сектора B, поэтому вместо n++, смело сделаем n += 2. Нам ведь не нужно делители искать надо узнать сколько. Так а что сектор A? пока n * n < x, мы проверяем d. Так:

X = 9. сперва d = 2. 2 * 2 < 9; X не делится на D, дальше. d++; d = 3; 3 * 3 = x; цикл завершен, так как 3 * 3 = 9, не меньше. И все 3 это делитель, поэтому в конце цикла после него добавим условие: если d * d = x, n++. Но так как d объявлено в цикле оно умрет вне него, выведем его в main:

```c++
#include <iostream>
using namespace std;

int main()
{
    int n = 0;
    long long x;
    cin >> x;
    long long d;
    for (d = 2; d * d < x; d++) {
        if (x % d == 0)
            n += 2;
    }

    if (x % d == 0) n++;

    cout << n << "\n";
    return 0;
}
```

А теперь проверка на простоту, на самом деле все просто, вместо += 2, ++ можно сделать n = 1; и break. если уже были нетривиальные делители в цикле, n = 1, а если еще и в if, то еще раз n = 1; дальше сделать if и если n = 1, то "complex" иначе если 0 "prime"

```c++
#include <iostream>
using namespace std;

int main()
{
    int n = 0;
    long long x;
    cin >> x;
    long long d;
    for (d = 2; d * d < x; d++) {
        if (x % d == 0)
            n = 1;
    }

    if (x % d == 0) n = 1;
    if (n == 1) cout << "Complex" << endl;
    if (n == 0) cout << "Prime" << endl;
    cout << n << "\n";
    return 0;
}
```

Превращаем в bool:

```c++
#include <iostream>
using namespace std;

int main()
{
    bool is_prime = true;
    long long x, d;
    cin >> x;
    for (d = 2; d*d < x; d++)
        if (x % d == 0) {
            is_prime = false;
            break;
        }
    if (d * d == x) is_prime = false;
    if (is_prime) cout << "prime\n";
    else cout << "complex\n";
    return 0;
}
```
Но тут можно заметить что if после for не нужен, там нужен быть при подсчете чтобы отличать + 1(если корень x) и + 2(в цикле). Тут и так и так нам нужен сам факт делимости:

```c++
#include <iostream>
using namespace std;

int main()
{
    bool is_prime = true;
    long long x, d;
    cin >> x;
    for (d = 2; d*d <= x; d++)
        if (x % d == 0) {
            is_prime = false;
            break;
        }
    if (is_prime) cout << "prime\n";
    else cout << "complex\n";
    return 0;
}
```

давайте вынесем вычисления в функцию, по этикету мы объявляем функции потом делаем main и сами функции:

```c++
#include <iostream>
using namespace std;

/// Проверка числа на простоту
bool is_simple(long long x);

int main() {
    long long x;
    cin >> x;
    bool is prime = is_simple(x);
    if (is_prime) cout << "prime\n";
    else cout << "complex\n";
    return 0;
}

bool is_simple(long long x)
{
    bool is_prime = true;
    long long d;
    for (d = 2; d*d <= x; d++)
        if (x % d == 0) {
            is_prime = false;
            break;
        }
    if (is_prime) return true;
    else return false;
}
```

а теперь возуемся тернарным оператором:


```c++
#include <iostream>
using namespace std;

/// Проверка числа на простоту
bool is_simple(long long x);

int main() {
    long long x;
    cin >> x;
    bool is prime = is_simple(x);
    cout << (is_prime ? "prime\n" : "complex\n")
    return 0;
}

bool is_simple(long long x)
{
    bool is_prime = true;
    long long d;
    for (d = 2; d*d <= x; d++)
        if (x % d == 0) {
            is_prime = false;
            break;
        }
    if (is_prime) return true;
    else return false;
}
```

Тернарный оператор довольно ситуативен и сложн и некрасивен, но пока он нам нужен хотя бы как пример, теперь давайте так, мы делаем лишнию строку `bool is prime = is_simple(x);`, и потом `is_prime`, 
но ведь в тернарном операторе тоже можно сделать так is_simple(x)!:


```c++
#include <iostream>
using namespace std;

/// Проверка числа на простоту
bool is_simple(long long x);

int main() {
    long long x;
    cin >> x;
    cout << (is_simple(x) ? "prime\n" : "complex\n")
    return 0;
}

bool is_simple(long long x)
{
    bool is_prime = true;
    long long d;
    for (d = 2; d*d <= x; d++)
        if (x % d == 0) {
            is_prime = false;
            break;
        }
    if (is_prime) return true;
    else return false;
}
```