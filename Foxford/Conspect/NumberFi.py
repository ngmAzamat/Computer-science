# Числа Фибоначи - рекурсивное решение, тут у меня закролось подозрение что все что делается циклом можно сделать и рекурсией. Фракталы итд

def fibonacci(n):
    if n <= 1: # Тут вопрос сложный, ведь вроде как есть разные варианты, и мне говорили что Первое число Фибоначчи - 0, второе число - 1, третье - 1, четвертое - 2
        return n
    return fibonacci(n - 1) + fibonacci(n - 2) 


# сделаем цикл, для того чтобы вывести первые 100 чисел фибоначчи

for x in range(100):
    print(x, fibonacci(x))

# Но почему-то на 32-33 итерации цикла он будет очень медленно вычислять, это серьезный минус рекурентных функций.

# Итак чтобы вычислить f(3) надо вычислить f(2) и f(1). Чтобы вычислись f(2) надо вычислить f(1) и f(0). Итак f(1) = 1, f(0) = 0. 1 + 0 = 1; Итого f(2) = 1. 
# А теперь мы вычисляем отдельно f(1) чтобы сложить это с f(2), и получить f(3). ЗАМЕТЬТЕ! МЫ УЖЕ ВЫЧИСЛЯЛИ f(1), но мы "забыли" и теперь мы снова вычислили что это 1. 1 + 1 = 2; Итого f(3) = 2;
# Кажется что легко, но допустим мы вычисляли f(4) и для этого нам надо было вычислить f(3) и f(2). f(3) мы только что вычислили, осталось вычислить f(2). 
# И тут главная проблема: Если бы мы Запомнили результат f(2) - мы же его вычисляли когда вычисляли f(3), нам бы не пришлось мы как болванам снова разбивать f(2) на f(1) и f(0)...
# В итоге вычисляя скажем f(40) вместо ОДНОГО действия, сложения запомненного нами f(38) + f(39). 
# Мы должны узнать каждое приведущее число фибоначчи по несколько раз(ведь наше дерево на две части поделится, f(39) и f(38)). Что приведет к тому что f(100) мы просто не сможем так вычислить скорее всего.

# Решение: надо как то кэшировать или запоминать числа фибоначчи:

from functools import lru_cache

fibonacci = lru_cache(fibonacci)

# Сейчас это фактически готовая реализация массива, все быстро вычисляется. Фактически сейчас если функция fibonacci с таким парамтером уже вызывалось при следующем вызыве ее не вызывают. 
# Объяснение: он запоминает все значения непонятно чего, судя по всему всего что ему дают
# но fibonacci = lru_cache(fibonacci) - это декоратор, можно просто выше написать 

@lru_cache(maxsize = 3)

# maxsize в скобках лишь обозночает сколько последних чисел мы запонимаем, пример дальше 3 чисел мы забываем(например чтобы не перегружать память), если не указывать maxsize он будет запоминать все и нам не нужны тогда скобки

# а теперь мы проводим эксперемент:

from functools import lru_cache

@lru_cache()
def fibonacci(n):
    print(f'fib({n}) called')
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2) 


print(5, fibonacci(5))

# Иными словами каждый раз когда функция вызываетсяя мы об этом пишем. 
# И теперь мы можем наглядно увидеть разницу между без лишних вызовов функции то есть с @lru_cache(), и с огромнным деревом вызовов фибоначчи - без @lru_cache()


# Пример изпользования, задача ЕГЭ 16
# Чему равно значение F(15)?

def F(n):
    if n > 2:
        return F(n - 1) + F(n - 2)
    else: # Необезательно писать else, так как если return все завершится и else точно не выполнится
        return 1

print(F(15))

# ВАЖНО! КЭШИРОВАНИЕ ВОЗМОЖНО ЛИШЬ ТАМ, ГДЕ ФУНКЦИЯ чистая, то есть не дает побочных эффектов но мы это уже обсуждали